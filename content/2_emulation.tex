
\chapter{Emulation}\label{ch:emulation}

\section{System Emulation}

The System Emulation emulates a whole system with hardware, the operating system (with the kernel) and the user space (with application processes). 
The system (hardware and operating system) will be translated unmodified. The benefit of system emulation (compared to user mode emulation) is that you can run priviledged instructions\cite{Butt2011}. 
Additionally, it can be used as an application development platform where specific hardware is not available. 
System emulation with emulated hardware is slower than a real machine because instructions executed directly in the guest guest hardware have to be emulated in software. 
That has got multiple host instructions because of the translation for a single guest instruction as a result\cite[~p.1]{Tong2014}.
It is posible to reduce the supported and attached additional devices with special options. \\
System emulation benefits from the virtualization support as KVM. So most CPU operations are not required to emulate.

\section{User Mode Emulation}

The User Mode Emulation does not emulate the whole system. It is possible to reproduce application processes in QEMU with a minimal system for a special application. 
This emulation type is working on a syscall level. Therefore, the application has to be runnable as a process executable itself. 
An external Linux kernel will be built and the application can be mounted via a loaded Docker image in a hard disk image. The emulator is using the Linux kernel to emulate system signal calls then. That can be managed by mapping system calls of the target to an equivalent system call on the host.
The user mode emulation can run directly non-priviledged instructions or is using system calls to ask for a special service from the operating system\cite{Butt2011}.


\section{QEMU}

QEMU is an open-source emulator available in most Linux distributions. It is embeeded in different virtualization tools as KVM and XEN, too. So QEMU is well tested and has got all necessary features for emulations. 
Additionally, you can emulate other architectures on different hardware. QEMU is a generic emulator and can emulate different system architectures. It can also be used for emulation of obsolete hardware\cite[~p.24]{Opsahl2013}. 
It has been extended for various architectures as x86, ARM, PowerPC, Sparc32, Sparc64, MIPS and s390x.
That is a processor emulator using binary translation\cite{Butt2011} which is executing and translating emulated code based on blocks. Each block has got one entry and one exit point\cite[~p.5]{Wang2010}. 
The binary translation will be executed with the "Tiny Code Generator" (TCG) inside of QEMU. 
That is a small compiler replacing GCC because of plenty releases and changes withit. The TCG is converting the blocks of target instructions into a default intermediate form. 
After that, it has to be compiled for the host or target architecture. 
If a binary for a new target architecture is necessary, the frontend of TCG will be converted while QEMU is ported to a new architecture. 
The TCG integrates new code for the new host architecture in the background then. It is also dedicted to improve performance with avoiding repeated translations by buffering already translated code\cite{Cota2017}. 
The TCG takes care of the emulation of the guest processor running as a thread launched by QEMU. The memory of a quest is allocated during launch and is mapped into the address space of the QEMU process\cite[~p.29]{Opsahl2013}.\\
It is possible to run unmodified guest operating systems. The open-source projects can use any Linux distribution as their base operating system then because QEMU is integrated as a package as default. 
QEMU does not emulate the whole hardware. That is only possible for the CPU. Therefore, QEMU is used for emulations in this Bachelor Thesis.

\section{Emulation of different architectures}

It is possible to emulate different architectures on another hardware architecture. The package qemu-user-static has to be installed then and the special architecture has to be registered in binfmt. binfmt\_misc is a kernel module. You can register other architectures within that, that you can run multiple other architectures on a host. So hybrid virtualization approach is possible with different virtualization technologies as with QEMU and Docker.


\subsection{binfmt\_misc}

\subsection{qemu-user-static}

\section{File Systems}

Docker is using the Union File System which is not compatible with QEMU.
QEMU can integrate only hard disks formated for default Linux file systems as ext2, ext3, ext4, XFS and Btrfs. 
The driver virtio\_blk is used to mount external file systems and emulates read/write in the physical block device\cite{Barboza2018}. Following it is possible to integrate and start nonnative systems in QEMU. 
Docker is advantageous to setup and start systems fast. 
So it would be nice to integrate the docker file system into QEMU. After building a docker image, it is possible export the file system into a directory with the name \textbf{rootfs} with the command 
\begin{lstlisting}[style=BashInputStyle]
docker export $(docker create initrd-s390x) | tar -C "rootfs" -xvf -
\end{lstlisting}
.
Linux has got the feature that it is possible to reformat directories for file systems and to copy/ mount content into this one. So it is possible to reformat the default docker file system UnionFS to another one as ext4 as an example. \\
QEMU is accepting the new file system as a block device for the guest system then. The default path to the mounted file system as a hard disk is \path{/dev/vda} as the first partition\cite[~p.22]{White2020}.

\subsection{Union File System}

Docker does not use any default Linux file system. 
Docker images are based on the Union File System (UnionFS)\cite[~p.21]{Ashraf2015}. 
This file system is using different file system layers with grouping directories and files in branches. 
The first layer is the typical Linux boot flile system with the name bootfs. 
That is working the same as in a Linux virtualization stack with using memory at first and unmounting to receiving RAM free by the initrd disk image. 
So the bootfs can be used inside of another Linux file system to mount in an virtualization stack for a successful boot process with QEMU.
The next layer contains the base image with the operating system given by the "FROM" command.
Then every docker command inside of the Dockerfile is adding an additional layer with the installation of applications or buildin binary files.
That is the reason that every executed docker command is receiving an own id in the disk memory during the build process.
Every separate docker command is using his own disk space. So a docker image can grow really fast.
It is reasonable to compress so much as possible of different routines into one docker command. 
All sizes of different docker layers will exist continuously inside of the new file system.

\subsection{Ext4}

Ext4 is a journaling file system (the same as ext3). The journal is registering transactional all changes on the operating system with meta data.
So no data  are lost after a system failure. They can be restored based on the journal without a save procedure by the user.
Such journal file systems in the ext file system familiy are working with blocks\cite[~p.20]{Seufert2015}.
The journal is splitted into the journal super block, descriptor blocks, commit blocks and revoke blocks.
The super block contains all meta data of the journal. Descriptor blocks include the special destination adress and a sequence number. 
Commit blocks are available to flag logged transactions.
Revoke blocks are flagging blocks not logged any more. \\
All meta data from the journal can be relocated in inodes because changes of file system meta data are registered, too. \\
The difference to the journal in ext3 are the option writing asynchronous commit blocks and additional ckeck sums for journal transactions\cite[p.28]{Seufert2015}.

Ext4 provides a better performance than ext3. 
This file system can be formated with mkfs.ext4 which is available in every Linux distribution.
This tool is creating a group despriptor table for further group descriptors what allows an expanding of the file system. The file system can grox a maximum of the multiple 1024 of his existing size because of the saved space\cite[p.21]{Seufert2015}.
Flex groups are used in ext4 for merging different block groups to one logic block group. All data from inodes are only saved in the first flex group then. 
So the search for files is more powerful because meta data are allocated at one place. \\

Another feature of ext4 is the possibility of inline files and inline directories. So small files and directories can be saved directly in inodes instead of data blocks. From this follows less disk space consumption\cite[p.24]{Seufert2015}.

