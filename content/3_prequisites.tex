\chapter{Prequisites}\label{ch:prequisites}


Different software is necessary to run qemu or docker for multiple architectures. Therefore, \textbf{docker} and \textbf{qemu} should be installed. Additionally, qemu-user-static \footnote{\url{https://github.com/multiarch/qemu-user-static}} and binfmt\_misc \footnote{\url{https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html}} are important for running multi-architecture containers. \\
\textbf{Root permissions} are required for installation, configuration and running emulated systems.

It is possible to install packages as \textbf{binfmt-support} and \textbf{qemu-user-static} by different Linux distributions, but it is recommended to use the latest version for s390x. \\

\section{Registration of Qemu-S390x}\label{Qemu-S390-Registration}

The packages \textbf{qemu-user-static} and \textbf{binfmt-support} should be installed because of the configuration. \\

The Linux kernel module binfmt\_misc can be mounted with the following command: \\
\lstinline!mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc!

The installed version 3.1 of qemu-user-static on Ubuntu 18.04 contains bugs that Docker images for s390 are not buildable on x86. Therefore, an upgrade to a new release is necessary.
Ultimate stable releases of qemu-user-static can be found under \url{https://github.com/multiarch/qemu-user-static/releases/}. The release v5.0.0-2 is used for the project and downloaded with \\
\lstinline!wget https://github.com/multiarch/qemu-user-static/releases/download/v5.0.0-2/x86_64_qemu-s390x-static.tar.gz! \\ 
for the specific version of qemu-s390x-static on x86. That is extracted to the directory \path{/usr/bin/} with the command \\ 
\lstinline!sudo tar -xvzf x86_64_qemu-s390x-static.tar.gz -C /usr/bin/! \\
afterwards. 
The architecture name before qemu is the architecture of the host system. The name between qemu and static is the emulated architecture. This archive contains only the new version for the unique architecture. The configuration will be used by the installed qemu-user-static.\\

s390x binaries have to be registered for s390x that they can be executable on x86. That is executed with the following command: \lstinline!sudo -i! and 
\begin{figure}[H]
\centering
\begin{boxedverbatim}
echo ':qemu-s390x:M::\x7fELF\x02\x02\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\
x02\x00\x16:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\
xfe\xff\xff:/usr/bin/qemu-s390x-static:OCF' > /proc/sys/fs/binfmt_misc/register
\end{boxedverbatim}
 \caption{Register S390x Binaries}
    \label{RegisterS390xBinaries}
\end{figure}

\section{Enabling Multi-Architecture Images}\label{Multi-Architecture-Images}

Docker is configured to build only for the own architecture, which is x86 at open-source projects. The "Experimental" flag exists for new available features which are not ready for production. So you can build docker images for s390x on x86. It can be added with the following configuration to the Docker daemon:
\begin{figure}[H]
\centering
\begin{boxedverbatim}
{
  "experimental": enabled
} >> /etc/docker/daemon.json
\end{boxedverbatim}
 \caption{Docker Experimental Flag}
    \label{DockerExperimentalFlag}
\end{figure}
The configuration of the Docker daemon is written in the JSON format. That is saved in \path{/etc/docker/daemon.json}.
After a restart of the docker daemon, there should be listed this experimental flag in the command  \lstinline!docker version!. An alternative way is to export this flag as an environment variable in the shell with  \lstinline!export DOCKER_CLI_EXPERIMENTAL=enabled! to enable it. Now it is possible to build docker images for s390x on x86 with \\ \lstinline!docker build --platform=linux/s390x -t image-example:s390x .! \\
based on a Dockerfile in the existing directory.

 
Additionally, a new version of BuildX is required. The pre-installed version of Docker has got bugs with the consequence of a broken build process with \textbf{Illegal instructions} at Go applications. This bug is fixed with the new version on Github. \\
Therefore, the new version has to be installed with:
\begin{figure}[H]
\centering
\begin{boxedverbatim}
git clone git://github.com/docker/buildx && cd buildx
make install
\end{boxedverbatim}
 \caption{BuildX Upgrade}
    \label{BuildXUpgrade}
\end{figure}
 

\section{Fetching Signed Linux Kernel Image} \label{LinuxKernel}

QEMU needs a built Linux kernel to start a full system emulation. There are the two options, to build the Linux kernel repeating because of security updates or to fetch the matching Linux kernel for the Docker image from the associated repository of the corresponding Linux distribution. \\ 
The build process via CI/CD should be fast. Therefore, the second option will be used. The Docker filesystem in rootfs does not contain any Linux kernel in the directory \path{/boot/}.
The prequisite for fetching of a signed Linux kernel image for a minimal system is the installed package \textbf{debootstrap}. This command line tool can download the filesystem of a minimal system to a sub directory on a Debian based system. There are additional options to specify the architecture with \lstinline!--arch=s390x! in our case and to include the Linux kernel with \lstinline!--include=linux-generic!. To receive only a minimal system, the additional option \lstinline!--variant=minbase! should be used. This command "debootstrap" is validating all downloaded packages additionally. This process is easy to automate and requires only 10 seconds. In conclusion, the generic and signed Linux kernel image can be used in the \path{/boot/} directory for the integration into QEMU.
 

\section{Optimized QEMU Command}\label{Optimized-Qemu-Command}

Every additional device requires additional performance and time for starting the system. 
So the systems requirements had to be figured out to be minimal for every given open-source project and for running tests on it. 
That counts for the number of CPUs, too. \\

The kernel option is receiving the path to the built s390x kernel with the name bzImage. In the given \ref{QEMU-Command}"Optimized QEMU command" the qemu command is executed in the directory with the built Linux kernel and the path is unimportant. \\  
The option \textbf{-m} is available to add the minimal guest memory matching the system requirements of every open-source project. \textbf{-M s390-ccw-virtio} defines the machine type for s390x.
\textbf{-nodefaults} is deactivating default additional devices activated in QEMU. 
Only the console is necessary for receiving an output and debugging. 
So this one is added as a device with \textbf{-chardev stdio,id=console,signal=off,mux=on -mon chardev=console} and \textbf{-device sclpconsole,chardev=console}. Additionally, the console has to be specified with \textbf{console=ttyS0} in the append part. \\ 
Cassandra as a project does not need any network interface (-net none) or parallelism (-parallel none). The option \textbf{-nographic} is responsible for not adding any graphical interface. 
So we save system requirements. The option \textbf{-smp} is the minimal number of CPUs for the guest. 
The file system of containers can be loaded as a hard disk with the option \textbf{-hda} which is explained in every chapter of the Bachelor Thesis for a considered open-source project. 
That is the ideal option to mount a minimal file system for every application or system. 
\path{/dev/vda} is the partition name and rdinit is used for using bash as a default shell. \\
This command can be used for user mode emulation with Apache Cassandra as an example.


\begin{figure}[H]
\centering
\begin{boxedverbatim}
/usr/bin/qemu-system-s390x -kernel bzImage -m 4G -M s390-ccw-virtio -nodefaults \
-device sclpconsole,chardev=console -parallel none -net none -chardev stdio,\
id=console,signal=off,mux=on -mon chardev=console -nographic -smp 3 \
-hda /data/cassandra.img  --append 'root=/dev/vda rw console=ttyS0 \
rdinit=/bin/bash'
\end{boxedverbatim}
 \caption{Optimized QEMU Command}
    \label{QEMU-Command}
\end{figure}

