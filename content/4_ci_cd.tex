\chapter{Continuous Integration}\label{ch:ci_cd}

\section{CI/CD in the Software Development Lifecycle}

CI/CD is the short name for Continuous Integration/Continuous Delivery. This method contains systems and technologies used for Test Driven Development. Continuous Delivery provides executing changes in the code, building them to an application and testing it directly. 
If all is working fine, it can be merged. Continuous Delivery is adding automated releases to the process. 
The software is tested automatically by the system before. If all is ok, it can be released.

These tests during the development are integrated into all sprints for agile software development. That has got the name DevOps after adapting these practices with expanding with automated deployments for operations. It is playing an important role through all phases in the software development because of the quality of code today. The code complexity is growing with the size of the project. Therefore, it is beneficially to have automated tests running directly after the commit. 

In the past, all systems had to be setup manually. Automating the software cycle and Test Driven Development (TDD) have promoted software for configuration managemant, CI/CD and version control. In combination, software can be deployed and tested over the full software development lifecycle. The Developer has the possibility to test his new written software before submitting and is receiving the feedback by the CI/CD system for the integration and system test whether his software is working in cooperation with other modules on multiple systems with their base operating systems.

This process should be automated. "Infrastructure as Code" is a provision for managing the setup of systems, networks and services via written code \cite[~p.110]{Scholl2019}. These servers are deployable on real servers in any data centre or in the public cloud. Using code as a base ensures that all systems have been installed and configured on the same way matching the system requirements. 

\section{Test Levels}\label{TestLevel}

Test suites can be executed repeatable and consistent with an point of view on the functionality, new requirements and software quality. These automated tests are part of the CI/CD pipeline with integrated deployments into system environments \cite[~p.112]{Scholl2019}. \\
Test suites can be splitted into different test levels:
\begin{itemize}
\item \textbf{Component Test}  \\
The component test can be called additionally unit test, module test or class test. 
It is testing the functionality of a special software component developed by the Developer \cite[~p.66]{Spillner2019}.
He has to extend the unit test with tests for new features for code coverage. These tests are mostly based on requirements and design documents \cite[~p.63]{Spillner2019}. In addition, the developed test cases of the component test have an effect on maintainability and efficiency.
The preparation with "Test First" is called Test Driven Development and is improving the code quality continuously.

\item \textbf{Integration Test} \\
The integration test is testing the matching of different modules. That is called software integration \cite[~p.71]{Spillner2019}. Some modules are using APIs (Application Programming Interface) for communication or have to correspond with other services.
Devices, the output and performance have to be checked in this level.
This test level can be performed with multiple connected containers for different services/ modules. Containers can represent sub systems. Bugs in interfaces and communication issues can be detected on this manner.
All in all, the system architecture of the complete system can be tested with integration tests.

\item \textbf{System Test} \\
The system test integrates all hardware and system requirement for the product \cite[~p.79]{Spillner2019}.
Every customer can use different hardware or services as a foundation. That can expect special system settings and can have an effect on the behavior of the system.
This test level includes tests for functional sustainability \cite[~p.87]{Spillner2019} and non-fuctional sustainability.
Performance testing, usability testing, security testing and compliance testing are part of non-functional sustainability. But also the system compatibility and tests with multiple configurations suit to non-functional tests. \\
Many software manufacturers are using live environments by their customers because of missing hardware for this test level. Integrated system emulations into the CI/CD pipeline would solve this problem.

\item \textbf{Acceptance Test} \\
The acceptance test requires users. The User Experience has to be tested on this test level. Mostly the Product Management and/ or the Customer Support are appointed for this task after the Alpha and Beta release. These release phases are executed before the final release for the possibility to fix critical or major bugs.
Some software companies are offering such releases for free, if a customer wants to test the software in the customer environment.
\end{itemize}
This order of test levels has to be kept. Most test phases can be automated with CI/CD.




\section{CI/CD Systems}

There is no one CI/CD system. These systems exist as open-source software and commercial software. They can integrate version control systems for automated tests of new software code or for their releases. \\
CI/CD systems can split their tests in different test cases or \ref{TestLevel}levels. Developers can define which test should run on which branch and in which phase. A branch is a code copy in a version control system as Github, Gitlab or SVN. It supports teams working parallel on the same code and to manage that. The code contribution by a single Developer should be tested and approved before the merge into the master branch. That can be triggered after the Pull Request via CI/CD. The Pull Request is a request to merge the offered code contribution to the master branch. This test before the merge is in the CI/CD stage for component tests. Afterwards, integration tests can be running in the next stage.