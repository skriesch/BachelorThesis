\chapter{Cassandra}\label{ch:cassandra}

\section{Overview}

Apache Cassandra is a Java based NoSQL database management system. It contains the commandline interface CQL for Cassandra database commands instead of SQL. It has to be recognized that the supported Java version by the open-source project Apache Cassandra can be changed with every version. That has to be recognized during the integration into the CI/CD pipeline of the project. There are different multi-arch Dockerfiles for all versions of AdoptOpenJDK to use. \\ 
This Apache project is using Circle CI for Continuous Integration.

\section{Installation}\label{Cassandra-Installation}

It should be created a Dockerfile\footnote{\url{https://github.com/s390x-container-samples/s390x-cassandra-ci-cd/blob/master/Dockerfile}} for a multi-arch image in this project with the reason for using it for different architectures.
Apache Cassandra is a Java based application. Therefore, the research has contained the search for a multi-arch image with pre-installed Java. The Cassandra version 3.11.6 is supporting Java 8. 
AdoptOpenJDK is maintaining multi-arch images for different Linux distributions with pre-installed AdoptOpenJDK.
In the description of \ref{AdoptOpenJDK-Multi-Arch}"Multi-Arch Image AdoptOpenJDK 8" is explained how the recommended Java version will be chosen for the specific architecture in this base image. 
This base image is integrated with \lstinline!FROM adoptopenjdk:8-jdk-hotspot! on top of the Dockerfile.

Apache Cassandra will be cloned from the Github repository with \\
\lstinline!git clone https://github.com/apache/cassandra.git!. \\
The special version is set with an agument with the ARG variable. On this way, it is possible to checkout other versions with a given argument as \lstinline!--build-arg CASSANDRA_VERSION=3.12.4! in the docker build command. \\
Apache Cassandra is using JNA (Java Native Library)\footnote{\url{https://github.com/java-native-access/jna}} as an extension of Java. JNA offers provides Java programs easy access to native shared libraries. The ant command is building the application and the JNA subsequently. \\
The command \lstinline!sed -i ' s/Xss256k/Xss32m/'! is setting the size of the frame stack (JVM stack) used by each thread to store local variables. This frame size is reduced to a minimum and stored in both files build.xml and conf/jvm.options.

\begin{figure}[H]
\centering
\begin{boxedverbatim}
FROM adoptopenjdk:8-jdk-hotspot
ARG CASSANDRA_VERSION=3.11.6
git clone https://github.com/java-native-access/jna.git \
&& cd jna \
&& git checkout 4.2.2 \
&& ant native jar \
# Build and install Apache Cassandra
&& cd $SOURCE_ROOT \
&& git clone https://github.com/apache/cassandra.git \
&& cd cassandra \
&& git checkout cassandra-${CASSANDRA_VERSION} \
&& sed -i ' s/Xss256k/Xss32m/' build.xml conf/jvm.options \
&& ant \
&& rm lib/snappy-java-1.1.1.7.jar \
&& wget -O lib/snappy-java-1.1.2.6.jar https://repo1.maven.org/maven2/org/xerial/snappy/
snappy-java/1.1.2.6/snappy-java-1.1.2.6.jar \
&& rm lib/jna-4.2.2.jar \
&& cd $SOURCE_ROOT \
&& cp $SOURCE_ROOT/jna/build/jna.jar $SOURCE_ROOT/cassandra/lib/jna-4.2.2.jar \
&& cp -R $SOURCE_ROOT/cassandra /usr/local/ \
\end{boxedverbatim}
 \caption{Cassandra Installation}
    \label{Cassandra-Installation}
\end{figure}


\section{Java Optimization}

Apache Cassandra should be allowed to use all available memory of the minimal system effectively.
Default the JVM is configured that only a part of that can be used. These configurations are set in the Java Options.
Afterwards, Apache Cassandra can work with a good performance. \\
Every major Java release can differ from another one with such options for Java optimization.

Following Java optimizations are available for Java 8: \\
\begin{itemize}
\item \textbf{-XX:+UseCGroupMemoryLimitForHeap}  \\
This option tells the JVM to look into \path{/sys/fs/cgroup/memory/memory.limit} after the available memory and to use the whole memory if necessary \cite{Flood2017}.
\item \textbf{-XX:ParallelGCThreads=2} \\
Apache Cassandra is referencing  2 required CPUs as a minimum in their documentation \cite{Cassandra}.
This JVM option permits 2 GC (Garbage Collection) threads parallel on different (virtual) processors.
\end{itemize}

All these Java optimization options can be set as an environment variable with \lstinline!ENV JVM_OPTIONS! in the Dockerfile. Then they will be used for every Java process like Apache Cassandra as an example.
As a result, Apache Cassandra can use the whole memory and delivered CPU, which is specified in the QEMU options.

\section{Nagios Monitoring Check for Tests}

Nagios is an open-source monitoring system to check the status of systems with their services. There are many checks for different services available. One monitoring check\footnote{\url{https://github.com/skyscrapers/monitoring-plugins/blob/master/check_cassandra.pl}} exists for Apache Cassandra. It is testing whether Java would be working, the service Apache Cassandra would be up and running, and whether CQL commands would be possible to execute without any issues. This Perl script is using \textbf{nodetool} for monitoring the JVM and the application. Nodetool is delivered together with Cassandra. It is connecting with the database and can dispense statistics about the Cassandra cluster / host \cite[~p.256]{Carpenter2020}. The result contains the status, information about memory usage and other capacities. This tool can indicate issues resulting in messages via the monitoring plugin in our case.\\
This monitoring check is written in Perl and is a nice choice for automated tests with error messages in the case if any output would not give an \textbf{OK}. \\
All monitoring plugins in the referenced Github repository are developed additionally for integration into Docker. Following, these scripts do not require any installed nagios system for monitoring.
Summarily, these monitoring plugins can be used for tests inside of our Dockerfile.


That said, \textbf{cassandra\_check.pl} is integrated into the Dockerfile with following commands at the end:
\begin{figure}[H]
\centering
\begin{boxedverbatim}
COPY plugins/cassandra_check.pl /bin/cassandra_check.pl
ENTRYPOINT ["perl", "cassandra_check.pl"]
\end{boxedverbatim}
 \caption{Cassandra Monitoring Check}
    \label{Cassandra-Monitoring}
\end{figure}

\section{Workaround Because of an JVM Issue}

Apache Cassandra is using OpenJDK 8 for running as default. There are some discussions\footnote{\url{https://lists.apache.org/thread.html/r38f6beaa22e247cb38212f476f5f79efdc6587f83af0397406c06d7c\%40<dev.cassandra.apache.org>}} about supporting OpenJDK 11 at the moment. The Dockerfile mentioned above is using AdoptOpenJDK 8 at the build process is working without any problems on Z systems. There exists a JVM issue during the build process on x86 which is the reason for non successful builds of Java applications there. That counts for all more complex Java applications.


This case has been tested with AdoptOpenJDK 8 and AdoptOpenJDK 11. The library hsdis-s390.so is not loadable for both Java versions on x86, but during the build process on s390x. This issue does not exist with the version AdoptOpenJDK 14, but Apache Cassandra does not work with this version. \\
That is an emulation bug of qemu which has to be fixed. This issue has been reported to KVM Developers inside of IBM. 

\begin{figure}[H]
\centering
\begin{boxedverbatim}
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGILL (0x4) at pc=0x0000004012539240, pid=18, tid=21
#
# JRE version: OpenJDK Runtime Environment (11.0.7+10) (build 11.0.7+10)
# Java VM: OpenJDK 64-Bit Server VM (11.0.7+10, mixed mode, tiered, compressed oops, 
g1 gc, linux-s390x)
# Problematic frame:
# J 1 c1 java.lang.Object.<init>()V java.base@11.0.7 (1 bytes) @ 0x0000004012539240 
[0x0000004012539200+0x0000000000000040]
#
# Core dump will be written. Default location: //core
#
# An error report file with more information is saved as:
# //hs_err_pid18.log
Compiled method (c1)     943    1       3       java.lang.Object::<init> (1 bytes)
 total in heap  [0x0000004012539010,0x00000040125393b8] = 936
 relocation     [0x0000004012539178,0x00000040125391a8] = 48
 constants      [0x00000040125391c0,0x0000004012539200] = 64
 main code      [0x0000004012539200,0x0000004012539300] = 256
 stub code      [0x0000004012539300,0x0000004012539358] = 88
 metadata       [0x0000004012539358,0x0000004012539370] = 24
 scopes data    [0x0000004012539370,0x0000004012539380] = 16
 scopes pcs     [0x0000004012539380,0x00000040125393b0] = 48
 dependencies   [0x00000040125393b0,0x00000040125393b8] = 8
Compiled method (c1)     948    1       3       java.lang.Object::<init> (1 bytes)
 total in heap  [0x0000004012539010,0x00000040125393b8] = 936
 relocation     [0x0000004012539178,0x00000040125391a8] = 48
 constants      [0x00000040125391c0,0x0000004012539200] = 64
 main code      [0x0000004012539200,0x0000004012539300] = 256
 stub code      [0x0000004012539300,0x0000004012539358] = 88
 metadata       [0x0000004012539358,0x0000004012539370] = 24
 scopes data    [0x0000004012539370,0x0000004012539380] = 16
 scopes pcs     [0x0000004012539380,0x00000040125393b0] = 48
 dependencies   [0x00000040125393b0,0x00000040125393b8] = 8
Could not load hsdis-s390x.so; library not loadable; PrintAssembly is disabled
#
# If you would like to submit a bug report, please visit:
#   https://github.com/AdoptOpenJDK/openjdk-support/issues
#
Aborted (core dumped) 
\end{boxedverbatim}
 \caption{JVM Build Issue}
    \label{jvm-issue}
\end{figure}


There is a workaround for the development process for finishing the project. The Docker image is buildable on s390x. Therefore, the Docker image has been built for s390x on s390x with \\  
\lstinline!docker build --squash -t cassandra .!. \\
Afterwards, this image can be saved as a tar archive with \\
\lstinline!docker save cassandra > cassandra.tar!\\ 
on the host. It has to be transferred with rsync to the x86 system then. The image inside of the tar archive can be included to all existing images of \lstinline!docker images! with the command 
\lstinline!docker load --input cassandra.tar!. \\
After this action, the Docker image is usable as it would have been built on this system. 
It can be integrated into QEMU and can be stated without any problems afterwards.




\section{Run Docker Image in QEMU}\label{RunningDockerImage}

The Docker image will be built with the command  \\
\lstinline!docker build buildx --platform=linux/s390x --squash -t cassandra:s390x .! \\
in the directory with the Cassandra Dockerfile  for the architecture s390x. \\
\textbf{Squash} is an option to compress a Docker image and combine commands in a Dockerfile automatically. The prequisites for building s390x images on x86 are set duiring the emulation preparation. The command \lstinline!docker images! has to show the registered Docker image with the name cassandra:390x then. It should be possible to integrate this Docker image into the qemu command. Therefore, a qemu-image will be created with an rounded given size besides of the Docker image in the  \lstinline!docker images! command. So the command \\  
\lstinline!qemu-img create -f raw cassandra-s390x.img 2G!  \\
can be used. This image needs any Linux file system because QEMU does not know the Docker file system. The image is formated with the command  \lstinline!mkfs.ext4 -F cassandra-s390x.img! then. For receiving the file system of the docker image a directory with the name rootfs has to be crated and the command \\
\lstinline!docker export $(docker create cassandra:s390x) | tar -C "rootfs" -xvf -!  \\ 
is exporting the docker image into the directory rootfs. Following transfers the content of rootfs into the image cassandra.img.

\begin{figure}[H]
\centering
\begin{boxedverbatim}
mkdir /mnt/rootfs
mount -o loop cassandra-s390x.img /mnt/rootfs
cp -r rootfs/* /mnt/rootfs/.
\end{boxedverbatim}
 \caption{Mount Rootfs}
    \label{Mount-Rootfs}
\end{figure}

\newpage
Now it is possible to run the system with Cassandra: \\
\begin{figure}[H]
\centering
\begin{boxedverbatim}
 /usr/bin/qemu-system-s390x -kernel bzImage -m 40G -M s390-ccw-virtio -nodefaults \
 -device sclpconsole,chardev=console -parallel none -net none -chardev stdio, \
 id=console,signal=off,mux=on -mon chardev=console -nographic -smp 3 \
 -hda /data/dockerfile-examples/ApacheCassandra/cassandra.img \
 --append 'root=/dev/vda rw console=ttyS0 rdinit=/bin/bash' 
\end{boxedverbatim}
 \caption{Run Cassandra}
    \label{RunCassandra}
\end{figure}

\section{Integration into CI/CD}

The community of Apache Cassandra is using Circle CI\footnote{\url{https://circleci.com/}} as a Continious Integration system.
This CI/CD system is connected with Github. The tests are running after every commit in the master repository.
These tests can run in a container or in a virtual machine. These options make it possible to build the Docker image for the architecture s390x and to integrate it into QEMU via the CI/CD pipeline without additional scripting or workarounds. \\
Circle CI is working with a yaml configuration\footnote{\url{https://circleci.com/docs/2.0/sample-config/}}. 
An enhancement is the opportunity to define shell commands with "command" in the yml file. Therefore, \ref{LinuxKernel}"Fetching Signed Linux Kernel Image" can be integrated. 
Additionally, dependencies can be created. On this way, it can be assured that the build process for the Docker image is triggered before the filesystem creation. 
The same counts for the kernel fetching process and the filesystem creation before the QEMU start. \\
This configuration file with the whole test process has got the name \textbf{config.yml}. \\
\textbf{Workflows} defines the order of different process steps with their dependencies with \textbf{- requires}.
The different processes are specified separately above then. The workspace can be declared. Running steps can receive names. Shell commands can be executed. Additionally, binaries and other files can be stored as artifacts. \\
The implementation of the job configuration can be found under \ref{CircleCI}.

