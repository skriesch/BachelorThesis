\chapter{Cassandra}\label{ch:cassandra}

\section{Overview}

\section{Deployment}\label{Cassandra-Deployment}

IBM is providing a Dockerfile\footnote{\url{https://github.com/linux-on-ibm-z/dockerfile-examples/tree/master/ApacheCassandra}} for Apache Cassandra especially for Z systems with the ultimate version of Cassandra on Github. This file can be cloned to the system and the Docker image will be built with the command  \lstinline!docker build --platform=linux/s390x --squash -t cassandra:s390x .! in the directory with the Cassandra Dockerfile  for the architecture s390x. \\
\textbf{Squash} is an option to compress a Docker image and combine commands in a Dockerfile automatically. The prequisites for building s390x images on x86 are set duiring the emulation preparation. The command \lstinline!docker images! has to show the registered Dockerimage with the name cassandra:390x then. It should be possible to integrate this Docker image into the qemu command. Therefore, a qemu-image will be created with an rounded given size besides of the Docker image in the  \lstinline!docker images! command. So the command  \lstinline!qemu-img create -f raw cassandra.img 2G! can be used. This image needs any Linux file system because QEMU does not know the Docker file system. The image is formated with the command  \lstinline!mkfs.ext4 -F cassandra.img! then. For receiving the file system of the docker image a directory with the name rootfs has to be crated and the command
\lstinline!docker export $(docker create cassandra:s390x) | tar -C "rootfs" -xvf -! is exporting the docker image into the directory rootfs. Following transfers the content of rootfs into the image cassandra.img.

\begin{lstlisting}[language=bash,caption={Mount rootfs},captionpos=b]
mkdir /mnt/rootfs
mount -o loop cassandra.img /mnt/rootfs
cp -r rootfs/* /mnt/rootfs/.
 \end{lstlisting}

Now it is possible to run the system with Cassandra: \\
\begin{lstlisting}[language=bash,caption={Run Cassandra},captionpos=b,label={RunCassandra}]
 /usr/bin/qemu-system-s390x -kernel bzImage -m 40G -M s390-ccw-virtio -nodefaults -device sclpconsole,chardev=console -parallel none -net none -chardev stdio,id=console,signal=off,mux=on -mon chardev=console -nographic -smp 3 -hda /data/dockerfile-examples/ApacheCassandra/cassandra.img --append 'root=/dev/vda rw console=ttyS0 rdinit=/bin/bash' 
 \end{lstlisting}
 
\section{Workaround Because of an Issue with JVMs During the Build with BuildX}

Apache Cassandra is using OpenJDK 8 for running as default. There are some discussions\footnote{\url{https://lists.apache.org/thread.html/r38f6beaa22e247cb38212f476f5f79efdc6587f83af0397406c06d7c\%40<dev.cassandra.apache.org>}} about supporting OpenJDK 11 at the moment. The Dockerfile mentioned above is using AdoptOpenJDK 8 at the build process is working without any problems on Z systems. There exists the following JVM issue during the build process on x86 which is the reason for non successful builds of Java applications there:

\begin{figure}[H]
\centering
\begin{boxedverbatim}
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGILL (0x4) at pc=0x0000004012539240, pid=18, tid=21
#
# JRE version: OpenJDK Runtime Environment (11.0.7+10) (build 11.0.7+10)
# Java VM: OpenJDK 64-Bit Server VM (11.0.7+10, mixed mode, tiered, compressed oops, 
g1 gc, linux-s390x)
# Problematic frame:
# J 1 c1 java.lang.Object.<init>()V java.base@11.0.7 (1 bytes) @ 0x0000004012539240 
[0x0000004012539200+0x0000000000000040]
#
# Core dump will be written. Default location: //core
#
# An error report file with more information is saved as:
# //hs_err_pid18.log
Compiled method (c1)     943    1       3       java.lang.Object::<init> (1 bytes)
 total in heap  [0x0000004012539010,0x00000040125393b8] = 936
 relocation     [0x0000004012539178,0x00000040125391a8] = 48
 constants      [0x00000040125391c0,0x0000004012539200] = 64
 main code      [0x0000004012539200,0x0000004012539300] = 256
 stub code      [0x0000004012539300,0x0000004012539358] = 88
 metadata       [0x0000004012539358,0x0000004012539370] = 24
 scopes data    [0x0000004012539370,0x0000004012539380] = 16
 scopes pcs     [0x0000004012539380,0x00000040125393b0] = 48
 dependencies   [0x00000040125393b0,0x00000040125393b8] = 8
Compiled method (c1)     948    1       3       java.lang.Object::<init> (1 bytes)
 total in heap  [0x0000004012539010,0x00000040125393b8] = 936
 relocation     [0x0000004012539178,0x00000040125391a8] = 48
 constants      [0x00000040125391c0,0x0000004012539200] = 64
 main code      [0x0000004012539200,0x0000004012539300] = 256
 stub code      [0x0000004012539300,0x0000004012539358] = 88
 metadata       [0x0000004012539358,0x0000004012539370] = 24
 scopes data    [0x0000004012539370,0x0000004012539380] = 16
 scopes pcs     [0x0000004012539380,0x00000040125393b0] = 48
 dependencies   [0x00000040125393b0,0x00000040125393b8] = 8
Could not load hsdis-s390x.so; library not loadable; PrintAssembly is disabled
#
# If you would like to submit a bug report, please visit:
#   https://github.com/AdoptOpenJDK/openjdk-support/issues
#
Aborted (core dumped) 
\end{boxedverbatim}
 \caption{JVM Build Issue}
    \label{jvm-issue}
\end{figure}

This case has been tested with AdoptOpenJDK 8 and AdoptOpenJDK 11. The library hsdis-s390.so is not loadable for both Java versions on x86, but during the build process on s390x. This issue does not exist with the version AdoptOpenJDK 14, but Apache Cassandra does not work with this version. \\
That is an emulation bug of qemu which has to be fixed. This issue has been reported to KVM Developers inside of IBM. \\

There is a workaround for the development process for finishing the project. The Docker image is buildable on s390x. Therefore, the Docker image has been built for s390x on s390x with  \lstinline!docker build --squash -t cassandra .!.
Afterwards, this image can be saved as a tar archive with \lstinline!docker save cassandra > cassandra.tar! on the host. It has to be transferred with rsync to the x86 system then. The image inside of the tar archive can be included to all existing images of \lstinline!docker images! with the command \lstinline!docker load --input cassandra.tar!. After this action, the Docker image is usable as it would have been built on this system. 

\section{Icinga Monitoring Check for Tests}

Icinga is an open-source monitoring system. There are many checks for different services available. One monitoring check exists for Apache Cassandra. It is testing whether Java would be working, the service Apache Cassandra would be up and running and whether CQL commands would be possible to execute without any issues. \\
This monitoring check is written in Perl and is a nice choice for automated tests with error messages in the case if any output would not give an \textbf{OK}. 

\section{Integration into CI/CD}